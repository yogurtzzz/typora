# 设计模式笔记

## 单例模式

* 饿汉式

  ```java
  public class Singleton{
      private static Singleton instance = new Singleton();
      private Singleton(){}  //限制住
      public static Singleton getInstance(){
          return instance;
      }
  }
  //多线程环境下可以保证只有一个实例
  //缺点：第一次加载类的时候，就会创建Singleton实例，若创建这个实例非常消耗资源，且程序很长时间没有使用这个Singleton的实例，则造成了系统资源的浪费
  ```

* 懒汉式(线程不安全)

  ```java
  public class Singleton{
      private static Singleton instance = null;
      private Singleton(){}
      public static Singleton getInstance(){
          if(instance == null){
              instance = new Singleton();
          }
          return instance;
      }
  }
  //优点：可以实现延迟加载，在需要用到Singleton实例的时候，再去创建
  //缺点：多线程环境下可能会创建两个实例，线程不安全
  ```

* 双重检查锁(Double Check Lock)

  ```java
  public class Singleton{
      private static Singleton instance = null;
      private Singleton(){}
      public static Singleton getInstance(){
          if(instance == null){
              synchronized(Singleton.class){
                  if(instance == null){
                      instance = new Singleton();  //代码A
                  }
              }
          }
          return instance;
      }
  }
  
  //优点：可以实现延迟加载，也能保证只有一个实例
  //缺点：有个很隐晦的致命问题
  //代码A那一行，实际可简单分为3个步骤
  //1. 申请内存                      memory_addr = mem_allocate();
  //2. 初始化对象                    initializeObject(memory_addr);
  //3. 内存地址赋值给instance         instance = memory_addr;
  //上述的3步操作中，2和3依赖于1，可以保证1一定是发生在2和3之前，但是2和3之间没有任何依赖关系
  //根据happens-before原则，JMM允许编译器和处理器对2和3进行可能的指令重排
  //若指令重排后
  //线程A先执行了1，再执行了3，此时instance有值，其值是分配到的内存地址，而此时内存地址中的对象数据还没初始化
  //若此时线程B调用了getInstance()方法，判断if(instance == null)为false，则会得到一个未经初始化的instance，此时若访问instance的字段或方法，会出现错误
  ```

  那么如何解决双重检查锁的问题呢 ->

* 通过静态内部类

  ```java
  public class Singleton{
      private Singleton(){}  
      private static class SingletonHolder{
          private static Singleton instance = new Singleton();
      }
      public static Singleton getInstance(){
          return SingletonHolder.instance;
      }
  }
  //优点：实现延迟加载，保证只有一个实例，并且无双重检查锁的问题
  //原理：
  //静态内部类的优点：外部类加载时，不会立即加载内部类，内部类贞加载，则不会在外部类加载时就初始化instance，只有当第一次调用getInstance()方法时，内部类SingletonHolder才会第一次被加载，类的加载是线程安全的。
  //这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化
  
  //缺点：然而，静态内部类创建单例并不就是最完美的，
  
  ```

  
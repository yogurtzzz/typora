## 数据类型

### 整型

| 类型  | 存储需求 |
| ----- | -------- |
| byte  | 1字节    |
| short | 2字节    |
| int   | 4字节    |
| long  | 8字节    |

长整型数值有一个后缀L，如`1L`

十六进制数值有一个前缀`0x` ，如`0xfe03`

二进制数值前缀是`0b`，如`0b100101`

### 浮点型

| 类型   | 存储需求 |
| ------ | -------- |
| float  | 4字节    |
| double | 8字节    |

float类型的数值有一个后缀F (3.14F)

没有后缀F的浮点数值，默认为double类型，当然，也能在浮点数后添加后缀D表示为double类型 (3.14D)



浮点数值不适用于禁止出现舍入误差的金融计算中

如`System.out.println(2.0-1.1)`; 会打印出`0.89999999`

这是因为0.1无法用二进制精确表示。

若需要在数值计算中不存在任何舍入误差，应该使用**BigDecimal**类



## 运算符

### 逻辑运算符

`&&`表示逻辑与

`||`表示逻辑或

这两个运算符都是按照"短路"求值的，即若第一个操作数已经能确定表达式的值了，就不会在继续计算后面的操作数

`exp1 && exp2`

 若`exp1`为false，那整个表达式不可能为true了，只能为false，`exp2`就不会进行计算了



`exp1 || exp2` 

若`exp1`为true，那整个表达式一定是true，`exp2`也就不会进行计算了



### 位运算符

 `&`      `|`      `^`      `~`      `<<`     `>>`    `>>>`

 与     或     异或   非      左移   右移   右移

`>>` 高位用符号位填充

`>>>` 高位用0填充

若将`&` 和 `|` 应用于布尔值，得到的结果也是布尔值，其行为和`&&` 和`||`非常相似，但`&` 和 `|` 不会按照 "短路" 方式进行计算，即，得到计算结果前，一定会计算2个操作数的值



**注意移位运算符，会对其右操作数进行 mod 32计算（若左边操作数是long类型，则右操作数会进行mod 64运算）**



```java
int a = 1 << 35;
int b = 1 << 3;
// a和b的值都是8

long x = 1L << 35;
long y = 1L << 3;
//x = 34359738368
//y = 8
```





```java
char a1 = 65;    //ASCII码
char a2 = '\101';  //101是八进制，算出来也是65
char a3 = '\u0041';  //Unicode码点
//上面3个char类型的变量，互相相等，打印出来都是A
System.out.println(a1 == a2);  
//true
System.out.println(a2 == a3);
//true
System.out.println("\uD835\uDD6B");
//

```





## 编码


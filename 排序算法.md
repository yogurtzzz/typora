# 排序算法

[参考链接](https://www.cnblogs.com/onepixel/articles/7674659.html)

## 内部排序

### 冒泡排序

* **原理**：每一趟对相邻的两个元素进行两两比较，若二者大小关系相反则交换，像鱼吐泡泡一样，一趟排序将一个最小值(或最大值)浮到顶端，最终达到完全有序

* 动图演示：

  

* 代码实现：

  ```java
  //bubble sort
  public void bubbleSort(int[] arr){
      for (int i = 0; i < arr.length; i++) {
              //每冒泡一次，最顶端的位置向前移一位
              for (int j = 1; j < arr.length - i; j++) {
                  if (arr[j - 1] > arr[j]) {
                      int temp = arr[j - 1];
                      arr[j - 1] = arr[j];
                      arr[j] = temp;
                  }
              }
          }
  }
  ```

### 选择排序

* **原理**：每一趟从待排序的元素中选择最小(或最大)的一个元素，放在已排好序的序列最后，直到所有元素有序为止，该排序算法是**不稳定的**。

* 基于此思想的算法主要有：简单选择排序，树形选择排序，堆排序

* 简单选择排序：

  ```java
  //simple select sort
  public void selectSort(int[] arr){
      for (int i = 0; i < arr.length; i++) {
              int min = i;
              for (int j = i + 1; j < arr.length; j++) {
                  //每一趟先选出最小的
                  if (arr[j] < arr[min]) {
                      min = j;
                  }
              }
          //然后将最小的放在第一个
          	if(min != i){
              	int temp = arr[i];
              	arr[i] = arr[min];
              	arr[min] = temp;
          	}
          }
  }
  ```

  

### 插入排序

* 简单插入排序

  * **原理**：将数组分为已排序的部分，和未排序的部分，初始时，可认为第一个数为已排序的序列，对未排序的序列，取出下一个元素，在已经排序的序列中从后往前扫描，找到合适的插入位置，插入该元素，直到全部有序

  * 代码实现：

  ```java
  //simple insert sort
  public void insertSort(int[] arr){
      for (int i = 1; i < arr.length; i++) {
              //每一轮从后面未排序的序列中，取出第一个元素
              int temp = arr[i];
              for (int j = i - 1; j >= 0; j--) {
                  //在前面下标为 0-i 的 已有序序列中，从后往前，寻找合适的插入位置
                  if (temp < arr[j]){
                      //采用逐个交换，将待插入元素，插入到合适位置
                      //其实思想应该是，找到合适位置后，插入，并将有序序列之后的元素，全部向后移一个位置
                      arr[j + 1] = arr[j];
                      arr[j] = temp;
                  }
              }
          }
  }
  ```

* 希尔排序   [参考链接](https://www.cnblogs.com/chengxiao/p/6104371.html)

  * **原理**：是简单插入排序的改进版，又称为**缩小增量排序**，按增量对数组进行分组，分组做直接插入排序，完成一趟后，缩小增量，直到增量为1，即最后一趟是直接插入排序

  * 代码实现：

    ```java
    //shell sort
    public void shellSort(int[] arr){
        //又被称作缩小增量排序，需要引入一个增量序列，最常用的序列是，n/2，n/4，n/8......1
            int increment = arr.length / 2;
            while(increment > 0){
                //第一趟
                for (int i = increment;i < arr.length; i++){
                    int j = i;
                    while(j - increment >= 0 && arr[j] < arr[j - increment]){
                        int temp = arr[j];
                        arr[j] = arr[j - increment];
                        arr[j - increment] = temp;
                        j -= increment;
                    }
                }
                increment /= 2;
            }
    }
    ```

    

### 归并排序

* **原理**：利用**归并**的思想实现的排序方法，该算法采用经典的**分治**（divide-and-conquer）策略（分治法将问题**分**(divide)成一些小的问题然后递归求解，而**治(conquer)**的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。

* 图示：

  ![mergeSort](E:\我的文件\技术类学习\web开发笔记\我的typora笔记\animation\mergeSort.png)

* 代码实现：(二路归并)

  ```java
  //two
  public void mergeSort(int[] arr){
      //需要一个临时数组
      int[] temp = new int[arr.length];
      mergeSort(arr,0,arr.length,temp);
  }
  
  public void mergeSort(int[] arr,int left,int right,int[] temp){
      //左闭右开
      if(left == right - 1) return ;
      //先分别对左右两边排序
      mergeSort(arr,left,(left + right)/2 , temp);
      mergeSort(arr,(left + right)/2, right, temp);
      //左右两边都有序后，合并
      merge(arr,left,mid,right,temp);
  }
  public void merge(int[] arr,int left,int mid,int right,int[] temp){
      int i = left, j = mid,pos = left;
      while(i < mid && j < right){
          //左闭右开
          if(arr[i] <= arr[j]){
              temp[pos++] = arr[i++];
          }else{
              temp[pos++] = arr[j++];
          }
      }
      //一边插入完毕后，另一边剩余的元素依次插入
      while(i < mid){
          temp[pos++] = arr[i++];
      }
      while(j < right){
          temp[pos++] = arr[j++];
      }
      //最后将结果拷贝回原数组
      for(int k = left; k < right; k++){
          arr[k] = temp[k];
      }
  }
  ```

  

### 快速排序

* **原理**：通过一趟排序将待排序的序列分成两个独立的部分，其中一部分的元素均比另一部分的元素要小，分别对这两部分继续进行排序，直到整个序列有序

* 算法描述：
  * 从序列中挑选一个元素出来，作为基准(pivot)
  * 对序列进行调整，使得所有小于pivot的元素，放在pivot的左边，所有大与pivot的元素，放在pivot的右边，这个操作称作**partition** (分区)
  * 递归地对pivot左右两边的子序列进行同样的排序操作（即，在子序列中继续选出一个pivot,并执行**分区**操作），直至整个序列有序

* 代码实现：

  ```java
  //quickSort
  public void quickSort(int[] arr){
      quickSort(arr,0,arr.length);
  }
  
  public void quickSort(int[] arr,int left,int right){
      //左闭右开
      if(left == right) return ;
      int pivot = arr[left];//以左边第一个元素为pivot
      int i = left,j = right - 1,pivotPos = left;
      boolean moveRight = true;
      //开始partition
      while(i != j + 1){
          if(moveRight){
              //先从右边开始移动
              if(arr[j] < pivot){
                  arr[pivotPos] = arr[j];
                  arr[j] = pivot;
                  pivotPos = j;
                  moveRight = false;
              }
              --j;
          }else{
              if(arr[i] > pivot){
                  arr[pivotPos] = arr[i];
                  arr[i] = pivot;
                  pivotPos = i;
                  moveRight = true;
              }
              ++i
          }
      }
      //partition结束，开始递归
      quickSort(arr,left,pivotPos); //对左分区进行partition
      quickSort(arr,pivotPos + 1,right); //对右分区进行partition
  }
  ```

  

* 堆排序

* 桶排序

**各种排序算法复杂度**

| 排序算法 | 时间复杂度(平均) | 时间复杂度(最坏) | 时间复杂度(最好) | 空间复杂度  | 稳定性 |
| -------- | ---------------- | ---------------- | ---------------- | ----------- | ------ |
| 冒泡排序 | O(n²)            | O(n²)            | O(n)             | O(1)        | 稳定   |
| 选择排序 | O(n²)            | O(n²)            | O(n)             | O(1)        | 不稳定 |
| 插入排序 | O(n²)            | O(n²)            | O(n)             | O(1)        | 稳定   |
| 希尔排序 | O(n^1.3^)        | O(n²)            | O(n)             | O(1)        | 不稳定 |
| 快速排序 | O(nlog~2~n)      | O(n²)            | O(nlog~2~n)      | O(nlog~2~n) | 不稳定 |
| 归并排序 | O(nlog~2~n)      | O(nlog~2~n)      | O(nlog~2~n)      | O(n)        | 稳定   |
| 堆排序   | O(nlog~2~n)      | O(nlog~2~n)      | O(nlog~2~n)      | O(1)        | 不稳定 |
|          |                  |                  |                  |             |        |
| 计数排序 | O(n+k)           | O(n+k)           | O(n+k)           | O(n+k)      | 稳定   |
| 桶排序   | O(n+k)           | O(n²)            | O(n)             | O(n+k)      | 稳定   |
| 基数排序 | O(n*k)           | O(n*k)           | O(n*k)           | O(n+k)      | 稳定   |



## 外部排序